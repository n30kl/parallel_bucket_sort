ЗМІСТ

ВСТУП	3
РОЗДІЛ 1. ОПИС АЛГОРИТМУ ТА ЙОГО ВІДОМИХ ПАРАЛЕЛЬНИХ РЕАЛІЗАЦІЙ	5
РОЗДІЛ 2. РОЗРОБКА ПОСЛІДОВНОГО АЛГОРИТМУ ТА АНАЛІЗ ЙОГО ШВИДКОДІЇ	7
РОЗДІЛ 3. ВИБІР ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ДЛЯ РОЗРОБКИ ПАРАЛЕЛЬНИХ ОБЧИСЛЕНЬ ТА ЙОГО КОРОТКИЙ ОПИС	11
РОЗДІЛ 4. РОЗРОБКА ПАРАЛЕЛЬНОГО АЛГОРИТМУ З ВИКОРИСТАННЯМ ОБРАНОГО ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ: ПРОЕКТУВАННЯ, РЕАЛІЗАЦІЯ, ТЕСТУВАННЯ	14
РОЗДІЛ 5. ДОСЛІДЖЕННЯ ЕФЕКТИВНОСТІ ПАРАЛЕЛЬНИХ ОБЧИСЛЕНЬ АЛГОРИТМУ (ПОРІВНЯЛЬНИЙ АНАЛІЗ ШВИДКОСТІ ОБЧИСЛЕНЬ)	17
ВИСНОВКИ	19
СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ	20
ДОДАТКИ	21
Додаток А	21


 
ВСТУП

Паралельні обчислення — це тип обчислень, при якому багато обчислень або процесів виконуються одночасно на одному процесорі. Великі проблеми часто можна розділити на менші, які потім можна вирішити одночасно. Існує кілька різних форм паралельних обчислень: бітовий рівень, рівень інструкцій, паралелізм даних і завдань. Паралелізм вже давно використовується у високопродуктивних обчисленнях, але він набув більшого інтересу через фізичні обмеження, що запобігають масштабування частоти. Оскільки енергоспоживання (і, отже, вироблення тепла) комп’ютерами стало проблемою в останні роки, паралельні обчислення стали домінуючою парадигмою в архітектурі комп’ютера, головним чином у формі багатоядерних процесорів.
Паралельні обчислення тісно пов'язані з одночасними обчисленнями — вони часто використовуються разом і часто змішуються, хоча вони різні: можна мати паралельність без паралельності та паралельність без паралельності (наприклад, багатозадачність за допомогою розподілу часу на одному- ядрі ЦП). У паралельних обчисленнях обчислювальна задача зазвичай розбивається на кілька, часто багато, дуже схожих підзадач, які можна обробляти незалежно і результати яких потім об’єднуються після завершення. Навпаки, у паралельних обчисленнях різні процеси часто не вирішують суміжні завдання; коли вони виконуються, як це типово для розподілених обчислень, окремі завдання можуть мати різноманітний характер і часто вимагати певного зв’язку між процесами під час виконання.
Паралельні комп’ютери можна приблизно класифікувати відповідно до рівня, на якому апаратне забезпечення підтримує паралелізм, при цьому багатоядерні та багатопроцесорні комп’ютери мають кілька процесорних елементів на одній машині, тоді як кластери, MPP та сітки використовують декілька комп’ютерів для роботи на одній машині. завдання. Спеціалізовані паралельні комп’ютерні архітектури іноді використовуються поряд із традиційними процесорами для прискорення виконання конкретних завдань.
У деяких випадках паралелізм є прозорим для програміста, наприклад, у бітовому рівні або паралельності на рівні інструкцій, але явно паралельні алгоритми, особливо ті, що використовують паралельність, складніше писати, ніж послідовні, тому що паралельність вводить кілька нових класи потенційних помилок програмного забезпечення, серед яких умови гонки є найбільш поширеними. Зв’язок і синхронізація між різними підзадачами, як правило, є одними з найбільших перешкод для досягнення оптимальної продуктивності паралельної програми [1].
В рамках виконання курсової роботи будуть виконані наступні завдання:
1)	Розробка та тестування послідовного алгоритму;
2)	Розробка та тестування паралельного алгоритму;
3)	Проведення порівняльного аналізу дослідження швидкодії алгоритмів при зростанні кількості даних для обчислень;
4)	Висновок про результати проведеного дослідження і переваги використання паралельних обчислень.
 
РОЗДІЛ 1. ОПИС АЛГОРИТМУ ТА ЙОГО ВІДОМИХ ПАРАЛЕЛЬНИХ РЕАЛІЗАЦІЙ

Блокове сортування (також відома назва кишенькове сортування, кошикове сортування, від англ. Bucket sort) — алгоритм сортування, в якому сортовані елементи розподіляються між кінцевим числом окремих блоків (кишень, кошиків) так, щоб усі елементи в кожному наступному по порядку блоці були завжди більшими, ніж у попередньому. Кожен блок потім сортується окремо або рекурсивно тим же методом або іншим. Потім елементи поміщаються назад у масив. Цей тип сортування може мати лінійний час виконання.
Переваги алгоритму: відноситься до класу швидких алгоритмів з лінійним часом виконання O(N).
Недоліки: сильно зростає час виконання при великій кількості мало відмінних елементів, або на невдалій функції отримання номера кошика вмісту елемента.
Робота алгоритму:
Якщо вхідні елементи підпорядковуються рівномірному закону розподілу, то математичне очікування часу роботи алгоритму кишенькового сортування є лінійним. Це можливо завдяки певним припущенням про вхідні дані. При кишеньковому сортуванні передбачається, що вхідні дані рівномірно розподілені на відрізку.
Ідея алгоритму полягає в тому, щоб розбити відрізок на n однакових відрізків (кишень), та розділити по цих кишенях n вхідних величин. Оскільки вхідні числа рівномірно розподілені, передбачається, що кожна кишеня потрапить невелика кількість чисел. Потім послідовно сортуються числа у кишенях. Відсортований масив виходить шляхом послідовного перерахування елементів кожної кишені.
Середня складність алгоритму визначається як: O(n + (n2/k) + k)
Псевдокод алгоритму наведений далі:
Function bucket_sort (Arr)
Argument list of elements
Create array of n empty buckets 
Compute a max value of elements
For each element
          put element in the bucket with  index element (n*element)
Return concatenation of all buckets 
Bucket Sort — це цікавий алгоритм, оскільки він намагається полегшити роботу іншого алгоритму, спочатку сортуючи елементи у пов’язані колекції, які називаються «відрами». Це не дуже корисний алгоритм для загальних випадків, але коли вхідний сигнал розподілений рівномірно, він може працювати за ефективний час [2]. 
Паралельно алгоритм можна реалізувати наступним чином.
Оскільки вхідні дані спочатку сортуються на певну кількість сегментів за лінійний час, а потім кожен сегмент сортується за допомогою алгоритму сортування на основі порівняння, сортування кожного окремого відра можна виконувати паралельно, що також може покращити продуктивність порівняно з алгоритмом послідовного сортування [3].
Ідея паралельного алгоритму: 
• Інтервали чисел, які призначені для кошиків рівномірно розташовані між числами a та b. 
• Для процесів P розділити інтервал [a, b] на P рівні шматків, Ip = [xp, xp+1) де xp = a + ph, h = (b − a)/P .
• Кожен процесор сканує свій локальний список і визначає, куди надіслати
елементи
• Після отримання всіх елементів відсортувати локальні списки
• Кожен процес повинен виконати порівняння N/P, де N дорівнює кількості елементів, а Р – кількості процесів. 
РОЗДІЛ 2. РОЗРОБКА ПОСЛІДОВНОГО АЛГОРИТМУ ТА АНАЛІЗ ЙОГО ШВИДКОДІЇ

Розробимо послідовний алгоритм. Створимо метод bucketSort, що буде відповідати за сортування масиву. На вхід метод буде приймати масив чисел. 
Крок 1. Створимо результуючий масив. 
Крок 2. Створимо масив кошиків.
Крок 3. Переберемо вхідний масив і додамо кожне число до відповідного кошику.
Виведемо заповнені кошики.
Крок 4. Кожний кошик додамо до результуючого масиву.
Лістинг коду наведений на рисунку 2.1 нижче.
 
Рис. 2.1 – Лістинг послідовного методу сортування bucketSort
В основному методі програми Main створимо масив з розміром, який користувач введе з клавіатури. Заповнимо такий масив довільними числами і виведемо на екран. Лістинг основного методу програми наведено на рисунку 2.2 нижче.
 
Рис. 2.2 – основний метод програми
Запустимо наш додаток. Введемо розмір масиву 3, 5 та 7 (для того щоб перевірити правильність роботи програми). Отримаємо наступний результат, зображений на рис. 2.3.
 
Рис. 2.3 – Робота програми
Як бачимо на рисунку 2.3 – програма працює вірно. Приберемо вивід початкового та кінцевого масивів, а також заповнених кошиків щоб вони не заважали при тестуванні масивів великих розмірів. 
Проведемо тестування алгоритму сортування на масивах розмірністю від 1 мільйону до 10 мільйонів елементів з кроком перевірки 1 мільйон елементів. Результати тестування алгоритму сортування BucketSort зображено на рис. 2.4.
 
Рис. 2.4 – Результати тестування алгоритму BucketSort
Перенесемо результати тестування BucketSort у таблицю 2.1.
Таблиця 2.1 - Результати тестування послідовного алгоритму BucketSort
К-ть елементів в масиві, млн	1	2	3	4	5	6	7	8	9	10
Час виконання, мс	55	133	195	277	330	429	525	543	638	781
 Перенесемо отримані дані на графік на рисунку 2.5
 
Рис. 2.5 – Графік залежності часу виконання 
програми від к-ті елементів масиву
З рис. 2.5 можемо бачити, що швидкість виконання програми лінійно (рівномірно) зростає зі збільшенням к-ті елементів масиву. Розробимо паралельний алгоритм для збільшення ефективності обчислень (зменшення часу виконання).

 
РОЗДІЛ 3. ВИБІР ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ДЛЯ РОЗРОБКИ ПАРАЛЕЛЬНИХ ОБЧИСЛЕНЬ ТА ЙОГО КОРОТКИЙ ОПИС

У мові програмування С# є кілька методів розпаралелення. Оскільки в обраному методі сортування є багато циклів, будемо використовувати клас Parallel і його метод For.
Клас Parallel є частиною TPL та призначений для спрощення паралельного виконання коду. Parallel має низку методів, які дозволяють розпаралелити завдання.
Метод Parallel.For дозволяє виконувати ітерацію циклу паралельно. Він має наступне визначення:
For(int, int, Action<int>)
Перший параметр методу визначає початковий індекс елемента в циклі, а другий параметр - кінцевий індекс. Третій параметр – делегат Action – вказує на метод, який виконуватиметься один раз за ітерацію.
Можемо навести приклад невеликої програми з використанням Parallel.For:
Parallel.For(1, 5, Square);
// обчислюємо квадрат числа
void Square(int n)
{
    Console.WriteLine($"Виконується завдання {Task.CurrentId}");
    Console.WriteLine($"Квадрат числа {n} дорівнює {n * n}");
    Thread.Sleep(2000);
}
В даному випадку як перший параметр метод Parallel.For передається число 1, а як другий - число 5. Таким чином, метод буде вести ітерацію з 1 до 4 включно. Третій параметр є метод, який обчислює квадрат числа. Оскільки цей параметр представляє тип Action<int>, цей метод як параметр повинен приймати об'єкт int.

А як значення параметра цей метод передається лічильник, який проходить в циклі від 1 до 4 включно. І метод Square, таким чином, викликається чотири рази. Приклад консольного виведення зазначеної вище програми наведений на рисунку 3.1.
 
Рис. 3.1 – Консольний вивід програми з 
використанням методу For класу Parallel
У стандартних циклах for і foreach передбачений передчасний вихід із циклу за допомогою оператора break. У методі Parallel.For ми також можемо, не чекаючи закінчення циклу, вийти з нього:
ParallelLoopResult result = Parallel.For(1, 10, Square);
if (!result.IsCompleted)
    Console.WriteLine($"Виконання циклу завершено на ітерації {result.LowestBreakIteration}");
// обчислюємо квадрат числа
void Square(int n, ParallelLoopState pls)
{
    if (n == 5) pls.Break(); // якщо передано 5, виходимо із циклу
    Console.WriteLine($"Квадрат числа {n} дорівнює {n * n}");
    Thread.Sleep(2000);
}
Тут метод Square, який обробляє кожну ітерацію, приймає додатковий параметр – об'єкт ParallelLoopState. І якщо лічильник у циклі досягне значення 5, викликається метод Break. Завдяки чому система здійснить вихід і припинить виконання методу Parallel.For за першої зручної нагоди.
Метод Parallel.For повертає об'єкт ParallelLoopResult, найбільш значущими властивостями якого є два наступні:
Метод IsCompleted: визначає, чи завершилося повне виконання паралельного циклу;
Метод LowestBreakIteration: повертає індекс, на якому відбулося переривання роботи циклу.
Так як у нас на індексі рівному 5 відбувається переривання, то властивість IsCompleted буде мати значення false, а LowestBreakIteration буде дорівнює 5 [4].


 
РОЗДІЛ 4. РОЗРОБКА ПАРАЛЕЛЬНОГО АЛГОРИТМУ З ВИКОРИСТАННЯМ ОБРАНОГО ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ: ПРОЕКТУВАННЯ, РЕАЛІЗАЦІЯ, ТЕСТУВАННЯ

Вихідним станом процесу проектування є точне формулювання результату алгоритму, який повинен бути отриманий при його виконанні. Отже, основною метою розробки паралельного алгоритму є досягнення прискорення обчислень, отриманих у результаті тестування послідовного алгоритму у розділі 2.
Оскільки вже фактично написаний алгоритм буде незмінним (кроки залишаються тими самими) і алгоритм розподілу чисел з інтервалу не змінюється, розглянемо ідею розпаралелення.
Очікуване прискорення відбуватиметься за рахунок використання методу розпаралелення циклів Parallel.For, розглянутого у попередньому розділі. Використаємо цей метод на двох кроках: для пришвидшення розподілу чисел у відповідні кошики (видалимо зайві змінні і розподіл напишемо в 1 рядок) а також для пришвидшення сортування чисел в кошиках і злиття їх в спільний результуючий масив.
Відкоригуємо роботу алгоритму. Весь лістинг програми, наведений у розділі 2 залишається незмінним. 
Введемо зміни у методі bucketSort. Замінимо цикли на кроках 3 та 4 на паралельні, з використанням методу For, наведеного у розділі 3. Лістинг розпаралеленого кроку 3 наведений на рисунку 4.1.
 
Рис. 4.1 – Розпаралелення циклу розподілу
чисел у кошики на кроці 3
Запустимо програму, перевіримо, чи коректно відбувається сортування. Результат роботи програми зображений на рисунку 4.2.
 
Рис. 4.2 – Результат роботи паралельного алгоритму
На рисунку 4.3 можемо бачити, що програма з використанням паралельних обчислень працює вірно, всі елементи сортуються і виводяться в правильному порядку. 
Оскільки все працює коректно, перейдемо до тестування алгоритму на даних, аналогічних до послідовної реалізації. Приберемо вивід масиву. Результат тестування наведений на рис. 4.3.
 
Рис. 4.3 – Результат тестування паралельного алгоритму
Перенесемо отримані значення у таблицю 4.1.
Таблиця 4.1. - Результати тестування 
послідовного алгоритму BucketSort
К-ть елементів в масиві, млн	1	2	3	4	5	6	7	8	9	10
Час виконання, мс	18	44	64	80	111	136	148	156	211	231
Перенесемо отримані дані на графік на рисунку 4.4.
 
Рис. 4.4– Графік залежності часу виконання 
програми від к-ті елементів масиву 
Перейдемо до порівняльного аналізу швидкодії паралельних обчислень.
 
РОЗДІЛ 5. ДОСЛІДЖЕННЯ ЕФЕКТИВНОСТІ ПАРАЛЕЛЬНИХ ОБЧИСЛЕНЬ АЛГОРИТМУ (ПОРІВНЯЛЬНИЙ АНАЛІЗ ШВИДКОСТІ ОБЧИСЛЕНЬ)

Для зручності аналізу, створимо таблицю 5.1, в яку перемістимо значення з таблиці 2.1 та 4.1. Також додамо рядок, в якому вирахуємо прискорення алгоритму шляхо5.1.м поділу часу виконання послідовного алгоритму на паралельний.
Таблиця 5.1 - Результати тестування послідовного 
і паралельного алгоритмів
К-ть елементів в масиві, млн	Кількість елементів масиву
	1	2	3	4	5	6	7	8	9	10
Послідовний алгоритм	55	133	195	277	330	429	525	543	638	781
Паралельний алгоритм	18	44	64	80	111	136	148	156	211	231
Показник прискорення	3,1	3,0	3,0	3,5	3,0	3,2	3,5	3,5	3,0	3,4
Перенесемо результати з таблиці на графік. Результат наведений на рисунку 5.1.
 
Рис. 5.1 – Графіки залежності часу виконання від кількості
елементів масиву для послідовного і паралельного алгоритмів
На рисунку 5.1 швидкість виконання послідовного алгоритму зазначена синім кольором, а швидкість паралельного – помаранчевим. З результатів, наведених у таблиці 5.1 та графіку просліджується прискорення роботи алгоритму більше, ніж на 1. Не зважаючи на те, що обидва графіки є лінійними – показник прискорення для великих масивів при використанні паралельних обчислень досягає 3,5, а отже основне завдання курсової роботи – виконано.
На швидкодію алгоритму впливає багато факторів, таких як:
- Технічні характеристики ПК;
- Версія середовища розробки (у більш нових версіях метод Parallel.For є удосконаленим і працює швидше ніж у старих, при розробці алгоритму використовувалася Visual Studio 2022);
- Розмір вхідного масиву (дослідження було виконано при різних розмірах);
- Діапазон значень: при занадто великій кількості однакових значень час, витрачений на сортування масиву значно збільшується (напр. діапазон сортування [1,10]), аналогічно збільшується час для занадто великих значень (напр. діапазон [1,100000]). Це добре помітно на великих об’ємах даних (від 10 000 елементів масиву).
Основним показником ефективності роботи алгоритму є оцінка швидкодії алгоритму. Для послідовного алгоритму ця оцінка складає O(n + k), де n – к-ть елементів, а k – к-ть кошиків. Для паралельного алгоритму оцінка складає O(log n). 
ВИСНОВКИ

Паралельні обчислення використовуються у великій кількості сфер людської діяльності, наприклад – моделювання атмосферних явищ, розв’язування задач прикладної та ядерної фізики, дослідження у галузях біотехнологій та генетики та багато інших. Усі сфери, у яких необхідно виконувати будь-які обчислювальні задачі потребують багато часу, на їх виконання. З метою пришвидшення обчислень – використовуються розпаралелювальні процеси, при розробці тих чи інших додатків.
Дізнатися, чи дійсно використання паралельних обчислень є обгрунтованим – було задачею курсової рботи. Отже, в ході досліджень та тестувань було виявлено, що послідовний алгоритм працював повільніше, ніж паралельний. Для відносно малих масивів (1 000 000 елементів) було отримано прискорення 3,5, що є суттєвою різницею. Для великих масивів (об’єм даних досягав 10 000 000 елементів) показник прискорення зменшувався, але був стабільним – 3,4.
Підсумовуючи, можна зробити загальний висновок: в ході розробки алгоритму сортування bucketsort та його паралельної реалізації було знайдено оптимальний розв’язок задачі і застосовано один із методів, що дозволяють виконувати паралельні обчислення на мові програмування C#.
